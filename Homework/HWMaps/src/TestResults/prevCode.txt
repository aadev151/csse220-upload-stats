packageMapsHW;importjava.util.ArrayList;importjava.util.HashMap;/******Class:Maps*@authorCSSEFacultyandAlexAnisimov*Purpose:providepracticewiththeHashMapdatastructureE*****************************************************************************************REQUIREDHELPCItATION:*https://stackoverflow.com/questions/35297537/difference-between-replace-and-put-for-hashmap****************************************************************************************/publicclassMaps{/***GiventwoarraysthisoperationmustbuildandreturnanewHashMapthat*containsamappingfromString(hashmap'skey)toInteger(hashmap'svalue)*lol*@paramairportCodesanarrayofStringcontaining3-letterairportcodes*@paramairportElevationsanarrayofIntegercontainingeachairport'selevationinmeters*@returnaHashMapcontainingamappingfromeachairportcodetoitselevaton*requires:noduplicateairportcodesarecontainedinarrayairportCodes-thatis,youcanprogramthisoperation*assumingthatthecallerwillmakesuretherearenoduplicatesinairportCodesarray*example:*inputairportCodes=["CDG","FOC","IND"]*inputairportElevations=[118,14,230]*returnvalue={CDG=118,FOC=14,IND=230}*/publicstaticHashMap<String,Integer>buildAirportMap(String[]airportCodes,Integer[]airportElevations){HashMap<String,Integer>airportCodesToElevations=newHashMap<String,Integer>();for(inti=0;i<airportCodes.length;i++){airportCodesToElevations.put(airportCodes[i],airportElevations[i]);}returnairportCodesToElevations;}//buildAirportMap//fewkjrlkjwelfjlewknjflj//jrlewjlrejlkrewj//rejwljrlkjewlkjrewlkjlkrejlrewlkrlkjewrlkjewrjlkrewjrewlkhgh;w/***GivenasingleinputstringininputString,thisoperationmustreturnthecharacter*frominputStringthatappearsthemostnumberoftimes**YoursolutionmustuseaHashMap;youcannotusenestedfor-loopstosolvethisproblem.*WhenyouuseaHashMapyouarepermittedtouse1forloop.**@paraminputString-stringofcharactersfordeterminingthemostcommoncharacter*@returnmostcommoncharacterthatappearedininputString*requires:inputStringwillnotbeemptyandtherewillbe1characterthatappearsmorethanalltheothers*Thatis,youcanprogramthisoperationassumingthatthecallerwillmakesurethatinputString.length()>0*andthattherewillbeonly1characterthat"wins"**example1:*inputinputString="aaab"*returnvalue='a'**example2:*inputinputString="abcbcdc"*returnvalue='c'*/publicstaticcharmostCommonCharacter(StringinputString){intmaxCount=1;charans=inputString.charAt(0);HashMap<Character,Integer>charsToTheirCounts=newHashMap<Character,Integer>();for(inti=0;i<inputString.length();i++){charletter=inputString.charAt(i);if(charsToTheirCounts.containsKey(letter)){intcurrentValue=charsToTheirCounts.get(letter);charsToTheirCounts.replace(letter,currentValue+1);}else{charsToTheirCounts.put(letter,0);}if(charsToTheirCounts.get(letter)>maxCount){maxCount=charsToTheirCounts.get(letter);ans=letter;}}returnans;}//mostCommonCharacter/***Inaparticularschool(notRose-Hulman)eachcoursecanonlyhave1pre-requisitecourse.**Thesepre-reqcoursesarerepresentedbyamappingfromcourseNametopreReqCourseName,forexample:**{"CS120"="","CS220"="CS120","CS230"="CS220","MA100"="MA102","MA102"="MA100"}**Notethatifacoursehasnopre-req,thepreReqCourseNameisrepresentedbytheemptystring""**Soinexampleabove,CS120hasnoprereqcourse.*CS220hasaprereqof120*CS230hasaprereqof220*MA100hasaprereqofMA102*MA102hasaprereqofMA100**YourjobistowriteanoperationthatcalculatesandreturnsthenumberofpreReqCourses*thatmustbetakenpriortotakingaspecificcourseToTake.**@paramcourseMapamappingfromcourseNametopreReqCourseName*@paramcourseToTakethenameofthecoursethatneedsitsprereqscountedup*@returnnumberofprereqcoursesrequiredtotakebeforetakingcourseToTake*or-1ifthecourseToTake'sprereqcoursesendsupincludingitself(seeexample4below)**example1:*inputcourseMap={"CS120"="","CS220"="CS120","CS230"="CS220","MA100"="MA102","MA102"="MA100"}*inputcourseToTake="CS120"*returnvalue=0**example2:*inputcourseMap={"CS120"="","CS220"="CS120","CS230"="CS220","MA100"="MA102","MA102"="MA100"}*inputcourseToTake="CS220"*returnvalue=1**example3:*inputcourseMap={"CS120"="","CS220"="CS120","CS230"="CS220","MA100"="MA102","MA102"="MA100"}*inputcourseToTake="CS230"*returnvalue=2**example4:*inputcourseMap={"CS120"="","CS220"="CS120","CS230"="CS220","MA100"="MA102","MA102"="MA100"}*inputcourseToTake="MA102"*returnvalue=-1*"MA102"areinaprereqinfiniteloop,thatis,byfollowingprereqsof"MA102",onecaneventuallygetbackto"MA102"*/publicstaticintgetNumberOfCoursesToTake(HashMap<String,String>courseMap,StringcourseToTake){intnumberOfPrereq=0;StringcurrentCourse=courseToTake;ArrayList<String>takenCourses=newArrayList<String>();while(courseMap.get(currentCourse).length()!=0){numberOfPrereq++;takenCourses.add(currentCourse);currentCourse=courseMap.get(currentCourse);if(takenCourses.contains(currentCourse)){return-1;}}returnnumberOfPrereq;}//getNumberOfCoursesToTake/***Duringaheatwave,anysignoflowertemperaturesbecomesbreakingnews.*Thisoperationtakesanarrayoftemperaturesandacorrespondingarrayofthecitynames*givingthelocationwhereeachtemperaturereadingwasrecorded.**Theoperationmustreturnthenameofacitythatexperiencedatemperaturedrop.*Ifnocityexperiencedadrop,theoperationshouldreturnnull.**YoumustuseaHashMaptosolvethisproblem.**@paramrecordedTempsthetemperaturesrecordedintimeorder*@paramcitiesnamesofthecitieswhereeachtemperaturewasrecorded*@returncitynamethathadatemperaturedropornullifnotemperaturedropinanycity*requires:only1citywillexperienceatemperaturedrop-thatis,youcanprogramthisoperation*assumingthatthecallerwillmakesurethatonlyonecityexperiencesatemperaturedrop**example1:*inputrecordedTemps=[90,100,90,99]*inputcityNames=["Seattle","LA","Seattle","LA"]*returnvalue="LA",because100to99wasadrop.**example2:*inputrecordedTemps=[91,92,80,93,100,83,93,82,105,85]*inputcityNames=["TerreHaute","TerreHaute","Seattle","TerreHaute","LA","Seattle","TerreHaute","Seattle","LA","Seattle"]*returnvalue="Seattle",because83to82wasadrop**example3:*inputrecordedTemps=[91,92,80]*inputcityNames=["TerreHaute","TerreHaute","Seattle"]*returnvalue=null,becausenocityexperiencedatemperaturedrop*/publicstaticStringgetTemperatureDropCity(int[]recordedTemps,String[]cityNames){HashMap<String,Integer>citiesToTemperatures=newHashMap<String,Integer>();for(inti=0;i<recordedTemps.length;i++){if(citiesToTemperatures.containsKey(cityNames[i])&&recordedTemps[i]<citiesToTemperatures.get(cityNames[i])){returncityNames[i];}else{citiesToTemperatures.put(cityNames[i],recordedTemps[i]);}}returnnull;}//getTemperatureDropCity/***Thisoperationreverses(i.e.,exchangesthekeysandvalues)aninitialMap.*initialMapmaycontainmultipledifferentkeyswiththesamevalue.*Becauseofthis,thevaluefieldofthereturnedmapmustbealist.**TheinitialHashMapcontainsamappingfromIntegerstoStrings.*ThereversedHashMapmustcontainamappingfromStringstoArrayListsofIntegers.**@paraminitialMaptheHashMaptobereversed*@returnanewHashMapwithkeysandvalues(frominitialMap)exchanged*keysfrominitialMapbecomevaluesinreturnedmap*valuesfrominitialMapbecomekeysinreturnedmap**example:*inputinitialMap={1=A,2=A,3=B}*returnvalue={A=[1,2],B=[3]}*/publicstaticHashMap<String,ArrayList<Integer>>reverseHashmap(HashMap<Integer,String>initialMap){HashMap<String,ArrayList<Integer>>reversedMap=newHashMap<String,ArrayList<Integer>>();for(Integerkey:initialMap.keySet()){Stringvalue=initialMap.get(key);if(reversedMap.containsKey(value)){reversedMap.get(value).add(key);}else{ArrayList<Integer>newEntry=newArrayList<Integer>();newEntry.add(key);reversedMap.put(value,newEntry);}}returnreversedMap;}//reverseHashmap}